{"id":"2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK","title":"top scoring links : rust","displayTitle":"Reddit - Rust","url":"https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Made a library with common 3D operations that is agnostic over the vector type","url":"https://www.reddit.com/r/rust/comments/1k4pj9s/made_a_library_with_common_3d_operations_that_is/","date":1745271750,"author":"/u/camilo16","guid":430,"unread":true,"content":"<p>I made <a href=\"https://crates.io/crates/euclidean\">euclidean</a>, a collection of functions for 3D euclidean geometry such as:</p><ul><li>Point to plane projection.</li><li>Triangle box intersection.</li><li>Segment-segment intersection.</li><li>Shortest points between two lines.</li></ul><p>The main Point of the library is that it uses another crate of mine  to abstract over the underlying linear algebra type. It works directly with nalgebra, but it should work (with no need of additional work on the user end) with many other vector types, provided they implement sane traits, like indexing, iterating over the values, supporting addition and scalar multiplication...</p><p>I hope this will be useful to some people.</p>","contentLength":616,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"faer: efficient linear algebra library for rust - 0.22 release","url":"https://github.com/sarah-quinones/faer-rs/","date":1745264147,"author":"/u/reflexpr-sarah-","guid":433,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1k4mg5a/faer_efficient_linear_algebra_library_for_rust/"},{"title":"I built a manga translator tool using Tauri, ONNX runtime, and candle","url":"https://www.reddit.com/r/rust/comments/1k4jdc9/i_built_a_manga_translator_tool_using_tauri_onnx/","date":1745256898,"author":"/u/mayocream39","guid":432,"unread":true,"content":"<p>The application is built with Tauri, and Koharu uses a combination of object detection and a transformer-based OCR.</p><p>For translation, Koharu uses an OpenAI-compatible API to chat and obtain the translation result. For more details about the tech, read the README at <a href=\"https://github.com/mayocream/koharu\">https://github.com/mayocream/koharu</a></p><p>I plan to add segment and inpaint features to Koharu...</p><p>I learn Rust for 3 months, and it's my first Rust-written application!</p>","contentLength":424,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"[Media]wrkflw Update: Introducing New Features for GitHub Workflow Management!","url":"https://www.reddit.com/r/rust/comments/1k4dwad/mediawrkflw_update_introducing_new_features_for/","date":1745243127,"author":"/u/New-Blacksmith8524","guid":431,"unread":true,"content":"<div><ul><li>Remotely trigger GitHub workflows right from your terminal with <code>wrkflw trigger &lt;workflow-name&gt;</code></li><li>Specify which branch to run on with the  option</li><li>Pass custom inputs to your workflow using </li><li>Get immediate feedback on your trigger request</li><li>Trigger workflows directly from the TUI interface by selecting a workflow and pressing </li></ul><ul><li>Smooth scrolling through logs with keyboard controls</li><li>Search functionality to find specific log entries</li><li>Log filtering by level (INFO, WARNING, ERROR, SUCCESS, TRIGGER)</li><li>Match highlighting and navigation between search results</li><li>Auto-scrolling that stays with new logs as they come in</li></ul><ul><li>Better error handling and reporting</li><li>Improved validation of workflow files</li><li>More robust Docker cleanup on exit</li><li>Enhanced support for GitHub API integration</li></ul><p>I'd love to hear your feedback on these new features! Do let me know what you think and what else you'd like to see in future updates. </p></div>   submitted by   <a href=\"https://www.reddit.com/user/New-Blacksmith8524\"> /u/New-Blacksmith8524 </a>","contentLength":916,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Pipelining might be my favorite programming language feature","url":"https://herecomesthemoon.net/2025/04/pipelining/","date":1745238165,"author":"/u/SophisticatedAdults","guid":434,"unread":true,"content":"<p><em> Don’t take it too seriously. Or do. idk, I can’t stop you.</em></p><p>Pipelining might be my favorite programming language feature.</p><p>\n              What is pipelining? Pipelining is the feature that allows you to omit a single argument from your\n              parameter list, by instead passing the previous value.\n            </p><p>When I say pipelining, I’m talking about the ability to write code like this:</p><div><pre tabindex=\"0\"><code data-lang=\"rust\"></code></pre></div><p>\n              As opposed to code like this. (This is not real Rust code. Quick challenge for the curious Rustacean, can\n              you explain why we cannot rewrite the above code like this, even if we import all of the symbols?)\n            </p><div><pre tabindex=\"0\"><code data-lang=\"rust\"></code></pre></div><p>\n              I honestly feel like this should be so obvious that it shouldn’t even be up for debate. The first code\n              example—with its nice ‘pipelining’ or ‘method chaining’ or whatever you want to call it—it\n              . It can be read line-by-line. It’s easy to annotate it with comments. It doesn’t\n              require introduction of new variables to become more readable since it’s already readable as is.\n            </p><p>\n              As opposed to, y’know,\n              <em>the first word in the line describing the final action our function performs</em>.\n            </p><p>\n              Let me make it very clear: This is an  about syntax. In practice,\n              <em>semantics beat syntax every day of the week</em>. In other words, don’t take it too seriously.\n            </p><p>\n              Second, this is not about imperative vs. functional programming. This article takes for granted that\n              you’re already on board with concepts such as ‘map’ and ‘filter’. It’s possible to overuse that style, but\n              I won’t talk about it here.\n            </p><h2>You already agree with me</h2><p>\n              Here is a feature that’s so bog-standard in modern programming languages that it barely feels like a\n              feature at all. Member access for structs or classes with our beloved friend the -operator.\n            </p><p>\n              This is a form of pipelining. It puts the data first, the operator in the middle, and concludes with the\n              action (restricting to a member field). That’s an instance of what I call pipelining.\n            </p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>\n              You see what I am getting at, right? It’s the same principle. One of the reasons why\n              -style member access syntax (and -style method call syntax!) is popular\n              is since it’s easy to read and chains easily.\n            </p><p>\n              Let’s make the comparison slightly more fair, and pretend that we have to write .\n              Compare:\n            </p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>\n              Which one of these is easier to read? The pipelined syntax, obviously. This example is easy to parse\n              either way, but imagine you’d like to blend out some information and purely focus on the final operation.\n            </p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>\n              You see the problem, right? In the first example, we have ‘all of the previous stuff’ and then\n               to it. In the second example, the operation which we want to perform\n              () and the new operand () are spread out with ‘all of the previous stuff’\n              sitting between them.\n            </p><p>Looking back at our original example, the problem should be obvious:</p><div><pre tabindex=\"0\"><code data-lang=\"rust\"></code></pre></div><p>\n              I cannot deny the allegations: I just don’t think it makes sense to write code like that as long as a\n              clearly better option exists.\n            </p><p>\n              Why would I have to parse the whole line just to figure out where my input comes in, and why is the data\n              flow ‘from the inside to the outside’? It’s kind of silly, if you ask me.\n            </p><p>\n              Readability is nice, and I could add add a whole section complaining about the mess that’s Python’s\n              ‘functional’ features.\n            </p><p>\n              However, let’s take a step back and talk about ease of editing. Going back to the example above, imagine\n              you’d like to add another  (or any other function call) in the middle there. How easy is\n              this?\n            </p><div><pre tabindex=\"0\"><code data-lang=\"rust\"></code></pre></div><ol><li>\n                You’ll have to parse through the line, counting commas and parentheses to find the exact place to add\n                the closing parenthesis.\n              </li><li>\n                The  of this is going to be basically unreadable, everything is crammed onto one\n                line.\n              </li><li>This line is getting long and unreadable, and at that point you’ll want to refactor it anyway!</li></ol><div><pre tabindex=\"0\"><code data-lang=\"rust\"></code></pre></div><p>\n              This is adding a single line of code. No parentheses counting. It’s easy and obvious. It’s easy to write\n              and easy to review. Perhaps most importantly, it shows up  in the\n               layer of whatever editor or code exploration tool you’re using.\n            </p><p>\n              You might think that this issue is  about trying to cram everything onto a single line, but\n              frankly, trying to move away from that doesn’t help much. It will still mess up your git diffs and the\n              blame layer.\n            </p><p>\n              You can, of course, just assign the result of every  and  call to a\n              helper variable, and I will (begrudgingly) acknowledge that that works, and is\n               better than trying to do absurd levels of nesting.\n            </p><p>\n              When you press  in your IDE, it will show a neat little pop-up that tells you which methods\n              you can call or which fields you can access.\n            </p><p>\n              This is probably the single IDE feature with the biggest value add, and if not that, then at least the\n              single most frequently used one. Some people will tell you that static analysis for namespace or\n              module-level code discovery is useless in the age of AI autocompletion and vibe coding, but I very much\n              disagree.</p><blockquote><p>\n                “grug very like type systems make programming easier. for grug, type systems most value when grug hit\n                dot on keyboard and list of things grug can do pop up magic. this 90% of value of type system or more to\n                grug” — grug\n              </p></blockquote><p>\n              Words to live by. What he’s describing here is something that essentially  pipelining to\n              work at all. (And types or type annotation, but having those is the direction the industry is moving in\n              anyway.)\n            </p><p>\n              It doesn’t matter if it’s the trusty  operator, C++’s , or if it’s\n              something more bespoke such as Elm’s or Gleam’s  or Haskell’s . In the\n              end, it’s a pipeline operator—the same principle applies. If your\n              <a href=\"https://en.wikipedia.org/wiki/Language_Server_Protocol\" target=\"_blank\">LSP</a> knows the type of\n              what’s on the left, it  in principle be able to offer suggestions for what to do next.\n            </p><p>\n              If your favorite language’s LSP/IDE does a poor job at offering suggestions during pipelining, then it’s\n              probably one of the following reasons:\n            </p><ol><li>\n                You don’t know which type you’re even holding. This happens most often when the language is dynamically\n                typed, ’types’ are hard to deduce with static analysis, and you’re touching/writing code without type\n                annotations. (e.g. Python)\n              </li><li>\n                The ecosystem and LSP just didn’t have enough time put into them, or most active users don’t care\n                enough. (e.g. any sufficiently obscure language)\n              </li><li>\n                You are in a situation in which even looking up which methods are available is hard, often due to a\n                bespoke build process that confuses the editor. (e.g. basically any build or runtime generation of code,\n                or bespoke loading/selection of libraries).\n              </li></ol><p>\n              In either case, great editor/LSP support is more or less considered mandatory for modern programming\n              languages. And of course, this is where pipelining shines.\n            </p><p>\n              Ask any IDE, autocompleting <code>fizz.bu... -&gt; fizz.buzz()</code> is  than\n              autocompleting , for the obvious reason that you\n              <em>didn’t even write  in the second example yet</em>, so your editor has less\n              information to work with.\n            </p><p>\n              Pipelining is  at data processing, and allows you to transform code that’s commonly\n              written with ‘inside-out’ control flow into ’line-by-line’ transformations.\n            </p><p>\n              Where could this possibly be more clear than in SQL, the presumably single most significant language for\n              querying and aggregating complex large-scale datasets?\n            </p><p>\n              You’ll be pleased to hear that, yes, people are in fact working on bringing pipelining to SQL. (Whether\n              it’s actually going to happen in this specific form\n              <a href=\"https://sqlite.org/forum/forumpost/2d2720461b82f2fd\" target=\"_blank\">is a different question</a>,\n              let’s not get too carried away here.)\n            </p><p>\n              Unless you’re one of those people who spends so much time dealing with SQL that it’s become second nature,\n              and the thought that the control flow of nested queries is hard to follow for the average non-database\n              engineer is incomprehensible to you, I guess.\n            </p><p>I’ll put their example of how a standard nested query can be simplified here, for convenience:</p><div><pre tabindex=\"0\"><code data-lang=\"sql\"></code></pre></div><p>Versus the SQL Syntax she told you not to worry about:</p><div><pre tabindex=\"0\"><code data-lang=\"sql\"></code></pre></div><p>\n              Less nesting. More aligned with other languages and\n              <a href=\"https://learn.microsoft.com/en-us/dotnet/csharp/linq/\" target=\"_blank\">LINQ</a>. Can easily be\n              read line-by-line.\n            </p><p>\n              Here’s a more\n              <a href=\"https://www.linkedin.com/pulse/not-so-good-idea-pipe-syntax-sql-franck-pachot-dx6he\" target=\"_blank\">skeptical voice (warning, LinkedIn!)</a>. Franck Pachot raises the great point that the  statement at the top of a query is\n              (essentially) its function signature and specifies the return type. With pipe syntax, you lose some of\n              this readability.\n            </p><p>I agree, but that seems like a solvable problem to me.</p><p>\n              And—surprise, surprise—it fits pretty well into pipelining. Any situation where you need to construct a\n              complex, stateful object (e.g. a client or runtime), it’s a great way to feed complex, optional arguments\n              into an object.\n            </p><p>\n              Some people say they prefer optional/named arguments, but honestly, I don’t understand why: An optional\n              named  parameter is harder to track down in code (and harder to mark as deprecated!) than\n              all instances of a  builder function.\n            </p><p>\n              If you have no clue what I’m talking about, this here is the type of pattern I’m talking about. You have a\n              ‘builder’ object, call some methods on it to configure it, and finally  the object\n              you’re actually interested in.\n            </p><div><pre tabindex=\"0\"><code data-lang=\"rs\"></code></pre></div><h2>Making Haskell (slightly more) readable</h2><p>\n              It has these weird operators like , , , or\n               and when you ask Haskell programmers about what they mean, they say something like\n              “Oh, this is just a special case of the generalized\n              <a href=\"https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:-62--61--62-\" target=\"_blank\">Kleisli Monad Operator</a> in the category of endo-pro-applicatives over a locally small poset.” and your eyes\n              have glazed over before they’ve even finished the sentence.\n            </p><p>(It also doesn’t help that Haskell allows you to define custom operators however you please, yes.)</p><p>\n              If you’re wondering “How could a language have so many bespoke operators?”, my understanding is that most\n              of them are just fancy ways of telling Haskell to compose some functions in a highly advanced way. Here’s\n              the second-most basic\n              example, the  operator.\n            </p><p>\n              Imagine you have functions , , and some value . In a\n              “““normal””” language you might write . In Haskell, this is written as\n              . This is since  will automatically ‘grab’ values to the right as its\n              arguments, so you don’t need the parentheses.\n            </p><p>\n              A consequence of this is that  is written as  in\n              Haskell. If you wrote , the compiler will interpret it as\n              , which would be wrong. This is what people mean when they say that Haskell’s\n              function call syntax is\n              <a href=\"https://en.wikipedia.org/wiki/Associative_property\" target=\"_blank\">left-associative</a>.\n            </p><p>\n              The  operator is <em>nothing but syntactic sugar</em> that allows you to write\n               instead of having to write . That’s it. People were\n              fed-up with having to put parens everywhere, I guess.\n            </p><p>If your eyes glazed over at this point, I can’t blame you.</p><p>\n              Talking about any of the fancier operators would be punching well above my weight-class, so I’ll just\n              stick to what I’ve been saying throughout this entire post already. Here’s a stilted Haskell toy example,\n              intentionally not written in\n              <a href=\"https://wiki.haskell.org/Pointfree\" target=\"_blank\">pointfree</a> style.\n            </p><div><pre tabindex=\"0\"><code data-lang=\"haskell\"></code></pre></div><p>\n              If you want to figure out the flow of data, this whole function body has to be read\n              .\n            </p><p>\n              To make things even funnier, you need to start with the  clause to figure out which\n              local “variables” are being defined. This happens (for whatever reason) at the end of the function instead\n              of at the start. (Calling  a variable is misleading, but that’s besides the\n              point.)\n            </p><p>\n              At this point you might wonder if Haskell has some sort of pipelining operator, and yes, it turns out that\n              one was\n              <a href=\"https://github.com/haskell/core-libraries-committee/issues/78#issuecomment-1183568372\" target=\"_blank\">added in 2014</a>! That’s pretty late considering that Haskell exists since 1990. This allows us to refactor the above\n              code as follows:\n            </p><div><pre tabindex=\"0\"><code data-lang=\"haskell\"></code></pre></div><p>Isn’t that way easier to read?</p><p> is code which you can show to an enterprise Java programmer, tell them that they’re looking\n              at\n              <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html\" target=\"_blank\">Java Streams</a>\n              with slightly weird syntax, and they’ll get the idea.\n            </p><p>\n              Of course, in reality nothing is as simple. The Haskell ecosystem seems to be split between users of\n              , users of , and users of the\n              <a href=\"https://hackage.haskell.org/package/flow-2.0.0.0/docs/Flow.html#g:1\" target=\"_blank\">Flow</a>-provided operators, which allow the same functionality, but allow you to write\n               instead of .</p><p>\n              I don’t know what to say about that, other than that—not entirely unlike C++—Haskell has its own share of\n              operator-related and cultural historical baggage, and a split ecosystem, and this makes the language\n              significantly less approachable than it has to be.\n            </p><h2>Rust’s pipelining is pretty neat</h2><p>\n              In the beginning I said that ‘Pipelining is the feature that allows you to omit a single argument from\n              your parameter list, by instead passing the previous value.’\n            </p><p>\n              I still think that this is true, but it doesn’t get across the whole picture. If you’ve paid attention in\n              the previous sections, you’ll have noticed that  and\n               share basically  in common outside of the order of\n              operations.\n            </p><p>\n              In the first case, we’re accessing a value that’s  to the object. In the second, we’re\n              ‘just’ passing an expression to a free-standing function.\n            </p><p>\n              Or in other words, pipelining is not the same as pipelining. Even from an IDE-perspective, they’re\n              different. In Java, your editor will look for methods associated with an object and walk up the\n              inheritance chain. In Haskell, your editor will put a so-called\n              <a href=\"https://downloads.haskell.org/~ghc/7.10.3-rc1/users_guide/typed-holes.html\" target=\"_blank\">’typed hole’</a>, and try to deduce which functions have a type that ‘fits’ into the hole using\n              <a href=\"https://herecomesthemoon.net/2025/01/type-inference-in-rust-and-cpp/\" target=\"_blank\">Hindley-Milner Type Inference</a>.\n            </p><p>\n              Personally, I like type inference (and\n              <a href=\"https://en.wikipedia.org/wiki/Type_class\" target=\"_blank\">type classes</a>), but I also like if\n              types have a namespace attached to them, with methods and associated functions. I am pragmatic like that.\n            </p><p>\n              What I like about Rust is that it gives me the best out of both worlds here: You get traits and type\n              inference without needing to wrap your head around a fully functional, immutable, lazy, monad-driven\n              programming paradigm, and you get methods and associated values without the absolute dumpster fire of\n              complex inheritance chains or AbstractBeanFactoryConstructors.\n            </p><p>\n              I’ve not seen any other language that even comes close to the convenience of Rust’s pipelines, and its\n              lack of higher-kinded types or inheritance did not stop it. Quite the opposite, if anything.\n            </p><p>\n              I like pipelining. That’s the one thing that definitely should be obvious if you’ve read all the way\n              through this article.\n            </p><p>I just think they’re neat, y’know?</p><p>I like reading my code top-to-bottom, left-to-right instead of from-the-inside-to-the-outside.</p><p>\n              I like when I don’t need to count arguments and parentheses to figure out which value is the first\n              argument of the second function, and which is the second argument of the first function.\n            </p><p>\n              I like when my editor can show me all fields of a struct, and all methods or functions associated with a\n              value, just when I press  on my keyboard. It’s great.\n            </p><p>\n              I like when  and the  layer of the code repository don’t look like\n              complete ass.\n            </p><p>\n              I like when adding a function call in the middle of a process doesn’t require me to parse the whole line\n              to add the closing parenthesis, and doesn’t require me to adjust the nesting of the whole block.\n            </p><p>\n              I like when my functions distinguish between ‘a main value which we are acting upon’ and ‘secondary\n              arguments’, as opposed to treating them all as the same.\n            </p><p>\n              I like when I don’t have to pollute my namespaces with a ton of helper variables or free-standing\n              functions that I had to pull in from somewhere.\n            </p><p>\n              If you’re writing pipelined code—and not trying overly hard to fit everything into a single, convoluted,\n              nested pipeline—then your functions will naturally split up into a few pipeline chunks.\n            </p><p>\n              Each chunk starts with a piece of ‘main data’ that travels on a conveyer belt, where every line performs\n              exactly one action to transform it. Finally, a single value comes out at the end and gets its own name, so\n              that it may be used later.\n            </p><p>\n              And that is—in my humble opinion—exactly how it should be. Neat, convenient, separated ‘chunks’, each of\n              which can easily be understood in its own right.\n            </p><p><em>Thanks to kreest for proofreading this article.</em></p>","contentLength":19143,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1k4c6nn/pipelining_might_be_my_favorite_programming/"},{"title":"Anyone hiring for rust interns ?","url":"https://www.reddit.com/r/rust/comments/1k49df9/anyone_hiring_for_rust_interns/","date":1745227712,"author":"/u/Recent_Project9124","guid":429,"unread":true,"content":"<p>I am a Rust enthusiast with one year of experience building personal system-level projects and I'm actively searching for a remote Rust internship.</p><p>I have build impressive project like DnsServer and HTTP server using TCP protocol and native networking library. I have designed these systems to be robust and multithreaded.</p><p>Beyond these i am also familiar with like git and docker</p><p>If your company is hiring Rust interns remotely, I'd love to connect and share more about my work..</p>","contentLength":476,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit","rust"]}